#ifndef LANDSCAPE_H
#define LANDSCAPE_H

#include <string>
#include <map>
#include <cmath>

#include "jungen_acc.cpp"
#include "gene.h"
#include "interaction_graphs.h"

/*
    LANDSCAPE

    The landscape defines the genotype to phenotype relationship for the set of genes used in the simulation
    It does this by providing a map (from the C standard library) that relates every possible genotype
    involving the genes, to their phenotype values based on the effects and dominance of the genes and alleles
    in the genotype
*/

std::vector<int> change_base(int, int, int);
std::string vec_ints_to_string(std::vector<int>);

class Landscape
{
    public:
        Landscape( int p, double a, int na, std::vector<Gene*> l, std::vector<IntGraph*> ig, double ev);

    //getters
        std::vector<Gene*> getLoci() { return m_loci; }


    //setters


    //landscape functions
        double findPhenotype(std::string i) { return m_l_map[i]; }
    // data management and display
        void printLandscape();

    private:
        int m_phenotype;
        double m_exp_value;        
	int m_num_ancestries;	
	std::vector<Gene*> m_loci;
	double m_error_var;
        double m_pheno_min;
        double m_pheno_max;
        
	std::vector<IntGraph*> m_epi_int;        
        std::map<std::string,double> m_l_map;

};

// LANDSCAPE CONSTRUCTOR
Landscape::Landscape( int p, double a, int na, std::vector<Gene*> l, std::vector<IntGraph*> ig, double ev = 0):
    m_phenotype(p), m_exp_value(a), m_num_ancestries(na), m_loci(l), m_error_var(ev), m_epi_int(ig) 
{
    // Begin generating keys for each genotype
    std::vector<Gene*>::iterator iter_g;
    int num_loci = m_loci.size();

    // We need to generate keys combinatorically for arbitrary numbers of genotypes at arbitraty numbers of loci
    // So we will use a combination counter
    std::vector<int> counter; // this acts like a counter, that counts down as genotypes are added, each position represents the number of genotypes remaining for a locus
    std::vector<int> zero; // a zero counter, all zeroes, does not change
    std::vector<int> reset; // this is a reset counter, the values are used to reset counter/digit values, does not change

    // initialize the actual counter, and zero and reset counters
    for( int i = 0 ; i < num_loci ; i++ )
    {
        std::cout << "LS_71: " << ( (*m_loci[i]).getGenotypes() ).size() << std::endl;
        counter.push_back( ( (*m_loci[i]).getGenotypes() ).size() - 1);
        reset.push_back( ( (*m_loci[i]).getGenotypes() ).size() - 1 );
        zero.push_back(0);
    }

    // the counters can be converted to strings to make keys, check values, and so forth
    std::string zero_string = vec_ints_to_string(zero);

    // compute the size of the landscape that is needed based on the number of loci, and genotypes
    int land_size = 1;

    for(iter_g = m_loci.begin() ; iter_g < m_loci.end() ; iter_g++ )
    {
        land_size = land_size * ( (**iter_g).getGenotypes() ).size();
    }

    // each genotype has two alleles for each locus
    //int keySize = m_loci.size() * 2;

    // match the keys (generated by each gene) to m_phenotype values
    for( int i = 0 ; i < land_size ; i++ )
    {
        std::vector<int> key; // store the key we generate
        std::vector<int>::iterator iter_c; // iterate over the counter
        std::vector<Gene*>::iterator iter_l; // iterate over loci

        // iterate over the loci, and the positions in the key simultaneously
        for(  iter_l = m_loci.begin(), iter_c = counter.begin() ; iter_l < m_loci.end(), iter_c < counter.end() ; iter_l++, iter_c++)
        {
            int c = *iter_c;
            std::vector<int> d = (**iter_l).getGenotype(c); // get the genotype value for the locus using the current index of the counter

            // each genotype from the gene is a vector of ints, so we push each int onto the key
            std::vector<int>::iterator iter_d;
            for(iter_d = d.begin() ; iter_d < d.end() ; iter_d++ )
            {
                key.push_back( *iter_d );
            }

        }

        // once the key is made, we iterate backward through the counter
        bool decrement = true;
        iter_c = counter.begin();
        int j = 0;
        while(decrement && iter_c != counter.end() )
        {
            if( *iter_c == 0 )
            {
                *iter_c = reset[j];
                iter_c++;
            }
            else
            {
                (*iter_c)--;
                decrement = false;
            }

            j++;
        }

        // now we calculate the phenotype value
        // beginning with te expected value of the phenotype
        double value = m_exp_value;

        // iterate over the key and calculate the phenotype
        std::vector<int>::iterator iter_k, iter_m;
        std::vector<Gene*>::iterator iter_g1 = m_loci.begin();
        std::vector<Gene*>::iterator iter_g2;
        std::vector<IntGraph*>::iterator iter_ig;

        double g_addEff = 0;
        double g_epiEff = 0;

        // get the additive effects
        for ( iter_k = key.begin(), iter_m = iter_k + 1 ; iter_m < key.end() ; iter_k+=2, iter_m += 2 )
        {
            g_addEff += (**iter_g1).getAddEffect(*iter_k) + (**iter_g1).getAddEffect(*iter_m);
            ++iter_g1;
        }

        // then the epigenetic effects
        for( iter_ig = m_epi_int.begin() ; iter_ig < m_epi_int.end() ; iter_ig++ )
        {
            int w = 0;  // used to count the index of each gene in the pair
            int x = 0;  //
            int y = -1; //
            int z = -1; //
            iter_g1 = m_loci.begin();
            iter_g2 = m_loci.begin();

            // iterate over possible gene pairs
            for (iter_g1 = m_loci.begin() ; iter_g1 < m_loci.end() ; iter_g1++, w++ )
            {
                if ( (*iter_g1) == (**iter_ig).getLocusA() )
                {
                    y = 2 * w;  // y is now the index of the locus at one of the interacting loci in the gene list
                    for (iter_g2 = m_loci.begin() ; iter_g2 < m_loci.end() ; iter_g2++, x++ )
                    {
                        if ( (*iter_g2) == (**iter_ig).getLocusB() )
                        {
                            z = 2 * x; // z is now the index of locus at the other interacting locus in the gene list
                        }
                    }
                }
            }

            // now that we have the indices we can check to see if the key indicates epistatic selection

            if( y > -1 && z > -1)
            {
                int a, b, c, d;
                a = key[y];
                b = key[y+1];
                c = key[z];
                d = key[z+1];
                g_epiEff += (**iter_ig).calc_Selection(a,b,c,d);
            }
        }

        // add the additive and epistatic effects to the initial phenotype value
        value = value + g_addEff + g_epiEff;
        // make a new key (string) value
        std::string newKey = vec_ints_to_string(key);
        // assign that key to the phenotype value
        m_l_map[newKey] = value;

    }
    //printLandscape();
}

// print out the landscape keys and values
void Landscape::printLandscape()
{
    std::cout << "Here is the genotype -> phenotype landscape for phenotype " << m_phenotype << "." << std::endl;
    std::map<std::string, double>::iterator iter_l;
    for(iter_l = m_l_map.begin() ; iter_l != m_l_map.end() ; iter_l++ )
    {
        std::cout << (*iter_l).first << "\t" << (*iter_l).second << std::endl;
    }
}

#endif // LANDSCAPE_H
