# HapHazard User Manual

Contents:
I. Introduction.....................................(line 9)
II. Setup and Getting Started.......................(line 32)
III. Input..........................................(line 97)
IV. Output..........................................(line 715) 

I. Introduction:
The HapHazard genomic ancestry simulator is a foward-in-time, individual based, population genomic
simulator of genomic ancestry. It was developed to study the effects of selection in hybrid zones
and is first described in:

Hvala JA, Frayer ME, Payseur BA. (2018). Signatures of Hybridization and Speciation in Genomic
Patterns of Ancestry. Evolution (under review).

To pursue this goal, HapHazard was developed to include complex population structures, in particular
the stepping stone cline model (Feldman and Christiansen 1974). It also includes multiple genetic
architectures of selection from single genes to networks with epistasis. Most importantly, HapHazard
uses ancestry junctions (Fisher 1954) to model hybrid genomes as mosaics of ancestry. Junctions arise
when recombination occurs between chromosome segments from different ancestries. Junctions accordingly
define the boundaries between ancestry tracts (or blocks). By using junctions to summarize the
ancesty of genomic tracts and ignoring sequence details, HapHazard can quickly and efficiently model
the behavior of admixing genomes with room left over for other complexities such as selection and
demography.

Feldman, M. W., and F. B. Christiansen. 1974. The effect of population subdivision on two loci
without selection. Genet. Res. 24: 151–62.

Fisher, R. A. 1954. A fuller theory of junctions in inbreeding. Heredity 8: 187–197.

II. Setup and Getting Started

System Requirements:
Linux (recommended, we used Ubuntu 14.04 and later)
Cygwin (if using Windows)
2 GB of RAM (at least)

Dependencies:
GNU scientific library: last compiled with v2.2 downloaded from http://ftp.wayne.edu/gnu/gsl/
Perl 5 (or later version)

Installation:

1. Download the zip file from this repsoitory (github.com/payseurlab/HapHazard).

2. Navigate to the folder containing the zip in the terminal and unzip the file using the command:

    $ unzip HapHazard-master.zip

3. Compile the program from source using the g++ compiler and linking GSL using the command:
		$ g++ -L/usr/local/lib main.cpp -o HapHazard -lgsl -lgslcblas -lm -std=c++11
	The link command -L/usr/local/lib links the compilation to gsl's default installation. If 
	you've chosen to install it elsewhere change this command appropriately. This command 
	should produce an executable file named 'HapHazard'. We also recommend using the c++11
	standard to compile the simulator.

Setting your First (Test) Run

The installation comes with the file 'HH_template.inp' which serves as an input template. The default 
parameters in it can be used to run a test simulation. It also contains instructions for the proper
input format. This file and its instructions are discussed below (see Input).

1. Install Perl if you have not already, and run the input generator script by typing:
   $ perl MakeHapHazInp.pl HH_template.inp
This command will run the input generation by processing the parameters listed in "HH_template.inp" 
and formatting them into a list that HapHazard can process which is stored in a file called "Homer.inp"
The file is named "Homer.inp" because "Homer" is the experiment name parameter given in "HH_template.inp".
Variables and default parameters for HapHazard are listed in "HH_template.inp" with brief explanations and 
instructions for how to use them.
   
2. To run Haphazard (on Linux) type:

   	$ ./HapHazard Homer.inp 0 555

HapHazard requires command line parameters to run. The first of the name of the input file as the first 
command line parameter, here it's "Homer.inp". This will vary depending on how you name your experiments. 
Next, you must specify a simulation number, in this case "0", and a random seed number, here it's "555". 
You can change these last two, but make sure that no two simulations have the same number or random seed. 
Having the same number will cause previous results to be overwritten, and any two simulations with 
exactly the same seed numbers (and parameter values) will be exact copies of each other. 

   To verify that the simulation is running properly check the output. The first line should say 
"HapHazard v1.0". The output should look like the contents of the "HapHazard_test_output.txt" file in this 
repository.
   
3. After finishing, there should be a folder called "Homer_0" in the HapHazard-master directory. In it, 
there should be the following files. "Homer.desc" list the parameters and their values that were used in the experiment. 
"Homer.0.499.clines" contains a list of the counts of each ancestry by chromosome and marker position, for 
each deme. The name of the file indicates that these were experiment Homer, simulation number 0, sample from 
generation 499, and the data are for measuring clines indicated by the extension. The file ending with 
".gclines", contains the same but the clines are genotypes. There should also be three folders, "BL_CHR0", 
"BL_CHR1", and "BL_CHR2". These folders contain the block length and marker data for the chromosomes indicated 
by the folder's name.

III. Input

Once you have verified that HapHazard works, you can start setting up your own experiments. To do this you 
will have to understand what HapHazard can do, and how to format the input to make HapHazard do it. This
section will show you how it's done by walking you through the input template file.

Input Template File Overview

"HH_template.inp", henceforth called the template, serves as a way to help users organize the input so that
the actual input file that HapHazard takes can be generated by the Perl script "MakeHapHazInp.pl", henceforth
referred to as the generator script. At the beginning of the template is the title, a brief intro, and a set 
of general instructions that we explain in a little more detail here. In this manual we'll separate lines
quoted from other files like this:

**********************************************************************************************************
**********************************************************************************************************
|
|HAPHAZARD INPUT FILE
|
|This file will serve as a template for HapHazard input. The lines will be read by a Perl driving
|script and used for input by HapHazard. Please read the instructions below. 
|
**********************************************************************************************************

Here is the first set of instructions from the template. 

**********************************************************************************************************
**********************************************************************************************************
|INSTRUCTIONS:
|
|Lines that begin with a '>' will be read as input. All other lines will be ignored and can be used 
|make notes or comments. The lines already contained in the file contain basic instructions and labels
|for lines of input. For more detailed instruction please see the HapHazard manual.
|
|HapHazard requires that all parameters be entered in the correct order.
|
|*** DO NOT DELETE OR ALTER THE ORDER OF THE INPUT PARAMETERS! *** 
|
|If you do so, HapHazard will likely crash or not run as expected. It is recommended that you maintain
|an unaltered template version of this file in case errors are made while altering the file for
|various experiments.
|
|Variable names below are on comment lines and named in ALL_CAPS_WITH_UNDERSCORES_FOR_SPACES to 
|distinguish them from variable types given in lowercase letters surrounded by carrots, <>. 
|Descriptions or instructions are given on lines following the variable name.
|
|Enter your variables on a line following the variable type after the '>' using the type 
|indicated above it. Leave a space between the '>' and the value Note: the term double, if you are not 
|familiar with it indicates a decimal number. The term double is used by computer scientists to indicate
|memory size andprecision. Don't worry about it, just enter a decimal.
|
|List variables are given one line with individual variables separated by spaces. Be aware of when # lists 
|need to correspond to one another. Many are warned of below, see the manual for details.
|
|This format can be tedious. Please take some extra time to prepare your list of parameters
|before entering them to avoid errors.
|
|
|END OF INSTRUCTIONS.
|
************************************************************************************************************

	Strictly speaking, the generator script will take any line with a '>' and try to generate the input
file using it. As mentioned, reordering the parameters will likely cause runtime errors and crashes of
HapHazard. Further, some parameters affect how the generator reads following lines of input (as we'll see
below) so be careful and pay close attention to where input parameters are placed.

The first input parameter is the Experiment Name.

************************************************************************************************************
************************************************************************************************************
|EXPERIMENT_NAME
|This is a label for your experiment and will be used to name output files and directories.
|<text>
|
|>MyExperiment
|
************************************************************************************************************

Very straightforward. Just make sure to give your experiment a clearly readable and recognizable name. It 
will be used to make a lot of files and folders for your results. Be sure to use underscores instead of spaces. 

Next is the number of simulations.

************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_SIMULATIONS
|The total number of simulations you would like to run
|If running jobs in parallel on a computer cluster, normally this should be set to 1.
|<integer>
|
|> 1
|
************************************************************************************************************

You can adjust this to run multiple replicates of your experiment. But, beware, depending on your parameter
choices running 100's or 1000's can take a while. Many of the experiments run in our study were done using
a distrubuted computing framework and were run in parallel. It would be good to keep this number small for
a test run or two to see how long one simulation takes.

************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_GENERATIONS
|The total number of generations you would like to run in each simulation
|<integer>
|
|> 500
|
************************************************************************************************************

HapHazard generations are discrete. After populations of individuals are setup, the generation
of each deme has several steps. First, individuals are chosen randomly to migrate to adjacent demes. Next, 
individuals are chosen randomly to make mating pairs. How pairs form depends on the mating system you select 
(see below). Once chosen, an individual is either accepted or rejected with a probability proportional to its 
reproductive fitness, as determined by other factors. Once two individuals are accepted, they each pass half 
their genome to one offspring. Recombination occurs during this mating step (more about recombination below). 
After mating, the parents are returned to the population and can be selected again. This 
sample-accept-recombine reproduction is repeated until a new generation of offspring reaches the carrying 
capacity of the deme or population.

************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_DEMES
|The number of demes found in your metapopulation, ignoring source populations
|<integer>
|
|> 1
|
|DEME_SIZES
|The number of individuals found in each deme. Enter as a list on one line separated by spaces.
|Make sure the number of list entries matches the number of demes.
|<integer_list>
|
|> 500
|
************************************************************************************************************

The number of demes is the number of "demes" or "sub-populations" in the simulation. Demes contain the 
number of individuals you specify in the list of deme sizes below it. These numbers are the carrying capacities
described previously.

!!!!! VERY IMPORTANT !!!!!
The number of sizes in the list, must match the number of demes.

When the generator script reads the number of demes, call it 5, it then looks for 5 deme sizes on the next line.
If those numbers are not there, the simulator will not be able to assign a deme size to missing deme sizes and
will crash. If you have 5 demes, your input must look like something like this:

************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_DEMES
|The number of demes found in your metapopulation, ignoring source populations
|<integer>
|
|> 5
|
|DEME_SIZES
|The number of individuals found in each deme. Enter as a list on one line separated by spaces.
|Make sure the number of list entries matches the number of demes.
|<integer_list>
|
|> 100 200 300 400 500
|
************************************************************************************************************

You can list any integers you like, they need not be the same, as long as the number of them is correct.

************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_ANCESTRIES
|The number of ancestries that exist in the population.
|
|> 2
|
|ANCESTRY_FREQUENCIES
|A list of each ancestry's frequency by deme. List each ancestry as they exist in each deme.
|The ancestry frequencies in each deme MUST SUM TO 1.0.
|For example: ancesty1_deme1, ancestry2_deme1, ancestry1_deme2, ancestry2_deme2, etc.
|<double_list>
|
|> 0.5 0.5
|
************************************************************************************************************

Above we state the number of ancestries that are included in the experiment and the initial ancestry
frequencies in the first generation. These frequencies will (very most likely) change as the simulator runs.

Similarly, the number of ancestries and the list of ancestry frequencies by deme must correspond to each other.
But, there must be as many as the number of ancestries times the number of demes in the ancestry list. So a
simulation with 3 ancestries and 4 demes needs twelve floating point numbers in the ancestry frequency list.
Further, each successive group of three, which corresponds to a deme MUST SUM TO 1.0.

Like this:

************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_ANCESTRIES
|The number of ancestries that exist in the population.
|
|> 3
|
|ANCESTRY_FREQUENCIES
|A list of each ancestry's frequency by deme. List each ancestry as they exist in each deme.
|The ancestry frequencies in each deme MUST SUM TO 1.0.
|For example: ancesty1_deme1, ancestry2_deme1, ancestry1_deme2, ancestry2_deme2, etc.
|<double_list>
|
|> 0.25 0.5 0.25 0.1 0.1 0.8 0.3 0.3 0.4 0.5 0.5 0.0
|
************************************************************************************************************

Notice how each group of three sums to 1.0 and there are 12 frequencies listed total. In each group of three,
the first will be indexed as 0, the second as 1, and the third as 2 in the simulator and output that follows.
So above, the frequency of ancestry 0 has initial frequencies in Demes 1-4 of 0.25, 0.1, 0.3, and 0.5. Note 
that the last deme has 0 of ancestry 2, and necessarily, ancestries 0 and 1 sum to 1.0. Though you need not 
a decimal point for 0, we do to remind ourselves that we always need a floating point (decimal) number. And
just to make sure its clear, they should all be positive and between 0 and 1 inclusively.

!!!!! IMPORTANT NOTE !!!!!
The simulations conducted to date have been performed with only 2 ancestries. Scenarios with more than 2 have
not been tested and we don't know for sure if the simulation runs correctly or not.

************************************************************************************************************
************************************************************************************************************
|The type of sex determination and mating system
|Enter: 0 for Hermaphrodites, 1 for XX females and XY males, or 2 for WZ females and ZZ males
|<integer>
|
|> 1
|
************************************************************************************************************

HapHazard simulates matings between bisexual diploids. Further, sex chromosomes and cytoplasmic inheritance
are included. 

Model 0 -- Hermaphrodites contain only autosomes and cytoplasm is inherited from a random parent. 

Model 1 -- XX females have two X chromosomes that can recombine normally. Whereas XY males have an X and a Y 
that only recombine in a restricted PAR region. The PAR region is simulated by multiplying the genetic length
of the X by a factor that reduces it to the desired size. Hence, the PAR is always on the 0 end of the 
chromosome. In this model, cytoplasm is only inherited from females, unless the cytoplasm is designated as 
pine chloroplast where it will be inherited from the male (see below).

Model 2 -- WZ females and ZZ males. The effects of heterogamy are reversed for males and females. Cytoplasm
is inherited from the female, unless its pine chloroplast.


************************************************************************************************************
************************************************************************************************************
|MIGRATION_RATES
|The proportion of individuals exchanged between pairs of demes each generation. Demes receive
|N* m/2 individuals from neighboring demes. Including migration with source populations, there
|should be the number of demes plus one migration rates. If you do not wish to include source
|populations, the first and last entry should be 0.
|<double_list>
|
|> 0.0 0.0
|
************************************************************************************************************

Again, it is important to specify the correct number of migration rates which is the number of demes plus one. 
In addition, their should always be a minimum of 2 numbers here since one deme could potentially recieve 
migrants from ancestal source populations.

The demographic model at this time only uses a stepping stone cline model (Feldman and Christiansen 1974).
There is a linear chain of demes between two source populations. Numbers specify the migration rate between 
a pair of adjacent demes. The first and last numbers in the list specify the migration rate between the flanking
source populations. The first number on the left will specify migration rate with the source population of
ancestry 0 and the last number will specify the migration rate with the source population for ancestry 1.

In the migration step of each generation in the simulation, the simulator moves from left to right, randomly
choosing and swapping a fraction of M/2 individuals from the two adjacent demes for each pair. For exchanges
with source populations, individuals from the end deme are replaced with individuals that have pure ancestry
and non-recombined chromosomes.

!!!!! IMPORTANT NOTE !!!!!
The behavior of >2 ancestries is untested. It is likely that no new migrants of ancestries 2 or higher would
enter the popualtion because their sources are not defined.


************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_CHROMOSOMES
|The number of chromosomes per haplotype. This includes up to one pair of sex chromosomes and
|one cytoplasmic chromosome.
|<integer>
|
|> 3
|
|RECOMBINATION_MODEL
|This parameter toggle the type of recombination used in the simulations
|0 = one crossover per chromosome
|1 = Poisson crossovers, no interference
|2 = Gamma Interference
|<integer>
|
|> 1
|
|CHROMOSOME_TYPES
|List the types of chromosomes used in the simulation. This list must correspond with other
|chromosome parameter lists.
|IMPORTANT NOTE: the sexchromosome pair, if used MUST be listed first, followed by any number of 
|autosomes, and the cytoplams MUST be listed last
|Options:<0> = autosomal pair, <2> = XY sex chromosome pair, <4> = ZW sex chromosome pair,  <5> = 
|mitochondrion, <6> = chloroplast, <7> = paternally inherited cytoplasm
|<integer_list>
|
|> 2 0 5
|
|CHROMOSOME_LENGTHS
|List the genetic length, in Morgans, of each chromosome in the same order the types appear in.
|The cytoplasm must be set to length 0.
|<double_list>
|
|> 1.0 1.0 0
|
|PSEUDO_AUTOSOMAL_REGION
|Set the genetic length of the pseudoautosomal region. In males, recombination between the X and Y
|is restricted to this fraction of the XY pair. If you wish to ignore it, set it to 0.
|<double>
|
|> 0.01
|
************************************************************************************************************

The above block defines the chromosomes of the genome and their behaviors. 

First we describe the number. Following this, the TYPES and LENGTHS must each have a number of entries that
equals the number of chromosomes.

!!!!! IMPORTANT !!!!!

There MUST be at least THREE chromosomes, and they must be the sex chromosome first, the autosome, and the
cytoplasm must be last. Additional autosomes, or even sex chromosomes, can be added to the middle. There can 
be only one cytoplasm. This is for the sake of organization. Chromosomes are held in an ordered "list" and 
the simulator expects to see a sex chromosome in the first position. Because the cytoplasm is unpaired, it is
placed last, and also marks the end of the "list".

RULES of INHERITANCE and RECOMBINATION

When the simulator selects two parents to create an offspring, it generates a "gamete" from each parent. For
each pair of chromosomes it will choose a chromosome to start with and it will decide how many crossovers, if
any, will occur on the chromosome. If no crossovers occur, the simulator will copy the parental chromosome
(essentially a list of junction positions and ancestries) into the new gamete. If any crossovers DO occur, the 
simulator will select their positions uniformly over the (genetic) length of the chromosome. Then, it scans 
the parental chromsome, and will switch to the other chromosome in the pair in segements that correspond to
the crossover events.

Autosomes: These pair and recombine just as described above.

Sex Chromosomes: These recombine just like autosomes when homogamic, but recombination will be restricted
to a PAR when heterogamic. They also, depending on the specified mating system, may determine the sexes of 
individuals. W and Y chromosomes do carry a unique, unrecombinant W and Y chromsome ancestry.

Cytoplasm: There must always be a cytoplasm in the last position of the genome, but there are some differences
among types. The mitochondrion and chloroplast are the same. Paternally inherited cytoplasm is inherited from
the paternal side. These are chromosomes with no recombination and hence no junctions, but they do possess 
ancestry and may be useful.

The simulator models genetic distance, probability of crossover occurrence, chromosome length is measured in 
Morgans. This length is used as the rate of recombination in the recombination model. However it is important
to note that the length of the chromosome represents an essentially physical map of where crossovers occur. 
In certain circumstances, such as when modelling a PAR region (see below), the uniformity of genetic distance 
will be altered. Any chromosomes that are not needed can be set to a length of zero. When this happens, they 
don't recombine or accumulate junctions, and hence, don't affect the simulation, run time, or computer memory.

The recombination model specifies the way recombination occurs. 

Model 0 = only one crossover is allowed per chromosome. It is drawn from a uniform genetic distance with a
rate equal to that distance.

Model 1 = the number of crossovers is drawn from a Poisson distribution and chromosomes are randomly placed
with uniform probability along the rest of the chromosome. The rate of the Poisson is the genetic length of
the chromosome.

Model 2 = Same as model 1, but the second and additional crossovers must be spaced according to a gamma
distributed model of crossover interference -- This model is untested, and furthermore, additional code will
be needed to  made the program accept parameters that alter this model.

The simulator models genetic distance, probability of crossover occurrence, chromosome length is measured in 
Morgans. This length is used as the rate of recombination in the recombination model. However it is important
to note that the length of the chromosome represents an essentially physical map of where crossovers occur. 
In certain circumstances, such as when modelling a PAR region (see below), the uniformity of genetic distance 
will be altered. Any chromosomes that are not needed can be set to a length of zero. When this happens, they 
don't recombine or accumulate junctions, and hence, don't affect the simulation, run time, or computer memory.

The psuedoautosomal region is simulated by allowing only one crossover in a limited region of the X
chromosome, and the number entered in this file tells what fraction of the X's genetic distance is to be used
as a PAR for the recombination of the X and Y Chromsomes. If you have a 1.0 M X chromosome, and the PAR is set
to 0.01, then for XY pairs, recombination will be restricted to one event at most in the first 1 x 0.01 = 0.01 M
of the X and Y chromosome. 


************************************************************************************************************
************************************************************************************************************
|EXPECTED_PHENOTYPIC_VALUES
|List the expected value of each phenotype. The genetic effects will be added later.
|See the manual for the phenotypic model being used. The fitnesses will be set to a
|expected value of 1.0 automatically. Only list the extra phenotypes you have included.
|If you have not added any phenotypes beyond three, the list will be ignored.
|<double_list>
|
|> 1.0 1.0 1.0
|
************************************************************************************************************

The simulator also includes phenotype modelling. All phenotypes are floating point numerical values. The
expected phenotypes above are the expected or mean values before genetic action occurs on the phenotype. This
will be discussed below. These can be any positive or negative decimal value.

The simulator has three "hidden" phenotypes. Reproductive, Developmental, and Environemental fitness. These 
three represent the probability of reproducing (producing a gamete during mating), surviving to reproductive 
age, and surviving in a given environment. Each is between 0 and 1.0.

Reproductive: Used as the probability to accept a parent during the pairing stage of the generation cycle.

Developmental: Used to determine whether a new offspring survives after being born. This function has not been
tested rigorously.

Environmental: Determines if an individual can survive in a given environment. While this feature is programmed
into HapHazard, the ability to define environments has not yet been added and the feature is not tested. 

************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_GENES
|Enter the number of genes you wish to define in the experiment.
|<integer>
|
|> 2
|
|GENE_PARAMETERS
|For each gene you wish to describe, list:
|its chromosome (the index in the genome list, 0...n-1)
|its position in Morgans, 
|the index of the phenotype it affects, 
|then the additive effect on the phenotype for each ancestry. 
|Make sure you list add've effects for each ancestry.
|Make sure the number of lines matches the number of genes specified above.
|Otherwise, the program will crash, or run improperly.
|<integer> <double> <integer> <double_list>
|
|Chr Pos Phen Add've_FX{by anc ... }
|> 0 0.5 0 0.0 0.0 0.0 0.0
|> 1 0.5 0 0.0 0.0
|
************************************************************************************************************

The above block shows how we define genes in the simulator.

First list the number of genes you are modelling so the generator knows how many to look for.

Next, list the parameters that define each gene, one gene per line. The genes you define will be entered into
an indexed list starting with the index of 0. These indices will be important in understanding how interactions
are defined below.

CHR = the chromosome the gene is on.

POS = the position of the gene in Morgans describing where it sits on the chromosome.

PHEN = the phenotype, 0 = reproductive fitness, 1 = developmental fitness, 2 = environmental fitness
3,4,5,... etc. = custom phenotypes.

Polygenic effects can be created by creating several genes that affect the same phenotype. Similarly, pleiotropic
effects can be simulated by creating several "genes" at one locus that effect several phenotypes.

ADD'VE_FX = each gene has a set of additive effects on the phenotype it affects. Here they are listed in order
by the ancestry. Ancestry is assumed to have allelic effects on phenotypes when genes are defined. These effects
cause deviations in the INDIVIDUAL's phenotype from the mean as specified. 

IMPORTANT: The number of additive effects must match the number of ancestries. If they do not match the simulation
will crash or generate extremely large output files. In addition, the sex chromosomes have double that number 
because the W and Z have a distinct ancestry value and thus their own effects must be defined. Note how the first 
gene on chromosome 0 (the sex chromosome) has four additive effects listed, instead of two as on the autosomal 
gene on chromosome 1.

************************************************************************************************************
************************************************************************************************************
|NUMBER_OF_INTERACTIONS
|Indicate how many epistatic interactions you would like to model.
|<integer>
|
|> 1
|
|GENETIC_INTERACTIONS
|Now we will list definitions of the interactions
|On a single line for each interaction, list
|The index of the first gene followed by the second. The index is the number, 0...n-1, of the
|gene in the list that that you specified earlier.
|Next list the ancestries of each gene that interacts in the same order.
|Follow this by the maximum phenotypic effect allowed for the loci (see manual for details)
|Next is the index of the phenotype the interaction effects.
|Finally, indicate the type of model you would like the interaction to follow from:
|0 = recessive, 1 = dominant, 2 = dom-rec, 3 = additive (see the manual for details)
|<integer> <integer> <integer> <integer> <double> <integer> <integer>
|
|Gene1 Gene2 Anc1 Anc2 MaxFX Phen Model
|> 0 1 0 1 -0.5 0 1
|
************************************************************************************************************

These two lines of input define how interactions among genes effect phenotypes. How we define interactions
between ancestries at genes can affect dominance and epistasis of genetic effects.

The first two numbers are the indices of the genes we want involved in the interaction. The next two numbers 
are the ancestries involved in the interaction. 

The next number describes the maximum phenotypic effect, followed by the phenotype affected, and the model of 
interaction. The affected phenotype is the index in the list of phenotypes we created earlier. The maximum
phenotypic effect sets the limit or often default value of the effect the interaction has on a phenotype
but can vary depending on the model selected. The models apply the max phenotype or some fraction of it
according to how dominance or additivity is affected by the number of possible interactions allowed in the 
genotype.

With two genes (A and B) and two ancestries (0 and 1), there are nine possible genotypes. When we consider only
a single pairwise gene by ancestry interaction (gene A ancestry 0 by gene B ancestry 1) only four of those genotypes
can have an interaction. They are:

Genotype:	  I 		  II		 III		 IV
Gene A:		0   1		1   0		0   0		0   0
Interaction:	  \		  / |		  \ |		| X |	
Gene B:		0   1		1   1		0   1		1   1
No. Int.	  1       	  2               2		  4

The lines on the middle row attempt to illustrate the interaction between the 0 ancestry of gene A, and the
1 ancestry of gene B. Between loci their are 4 total interactions possible. The number of interactions for each
genotype for the example scenario are listed beneath each genotype.

In the above example we are creating an interaction between the first two genes, and only two genes we've 
created that have an interaction when gene 0 has ancestry 0 and gene 1 has ancestry 1. There is a max effect of
-0.5 set to affect the reproductive fitness phenotype (0) and the interaction model is dominant (1).

If left as is, then the max effect of 0.5 would apply to genotypes I, II, III, and IV.

The dominant model (1) applies the max phenotypic effect to any genotype where this interaction occurs. Thus,
individuals with any of the genotypes (I, II, III, and IV) will have the max effect applied to their phenotype.

The recessive model (0) applies the max phenotypic effect to only individuals with genotype IV, and not to any
genotype in which the dominant interaction can "rescue" or "mask" the effect of the recessive. Genotypes I, II,
and III will not be affected.

The dominant-recessive model (2) treats the first gene we list for the interaction as dominant, and the second
as recessive. Thus, only genotypes II and IV will have the max effect applied.

The additive network model (3) applies a fraction of the max effect (E) according to the number of interactions 
in the genotype out of the total possible. So, Genotypes I, II, III, and IV would get 1/4*E, 2/4*E, 2/4*E, and
4/4*E respectively.

These interactions can also be used to  simulate single locus phenotype models with dominance. In those cases
you could set the interaction to occur between one gene and itself.

For example:

************************************************************************************************************
************************************************************************************************************
|
|Gene1 Gene2 Anc1 Anc2 MaxFX Phen Model
|> 1 1 0 0 -0.5 0 0
|
************************************************************************************************************

Would create a gene in which the 0 ancestry is recessive to the 1 ancestry, and causes a -0.5 reduction in the
0 Phenotype's value when it occurs. This line tells the simulator to look for an ancestry 0-0 interaction at
gene 1's locus and apply -0.5 when only that interaction occurs.

************************************************************************************************************
************************************************************************************************************
|SAMPLE_SIZE
|Enter the number of individuals you would like to collect from each deme when summary statistics
|are calculated
|<integer>
|
|> 10
|
|MARKER_SPACING
|Indicate the size of the interval in Morgans between genetic markers. 
|<double>
|
|> 0.01
|
|SUMMARY_GENERATIONS
|List the generations, 0...t-1, in which you would like to collect summary statistics.
|At the end of the list, include a number outside the range (this tells the program to stop
|reading the list)
|<integer_list>
|
|> 499 9999999
|
|SUMMARY_STATS
|List a boolean value, 0 = false, 1 = true, to turn off or on (respectively) the summary statistics
|The order of the list is:
|Geographic clines, Geographic genotypic clines, Ancestry Blocks
|<boolean>
|
|> 1 1 1 1 1 1
|
|And that's it!
|
|END INPUT
|
************************************************************************************************************

This last group of inputs defines the data collection routine used in the simulation.

The Sample Size is straighforward. The simulator will select this number of individuals from each deme in the
experiment when in generations in which it is set to collect data.

The marker spacing tells the simulator the distance in Morgans between uniformly spaced markers. The markers are
used to generate files tha contain genotype data for all the markers listed. The simulator does create these markers
but the data found in the .mkr files are generated by the Perl script haphazard_makemarkers.pl.

Summary generations is a list of all the generations you would like to collect data from. The simulator begins with
generation zero and runs until T-1 generations. The last number in this list must be greater than the total number
of generations to tell the input routine to stop looking for more sampling/summary generations.

Summary stats are boolean values that were used at one point to toggle on/off summary stat calculating functions.
Subsequently, many of these functions were replaced with post processing Perl and R scripts. However, the simulator
stil requires these all be turned on to function properly. 


IV. Output

In this section we'll walk through the folders and files that are generated as output by our test run named
"Homer".

Let's say we ran our test run in a folder named "Homer". This folder contains our executable, the
input file, and the perl script 'Haphazard_makemarkers.pl'.

After running, we'd add a folder called Homer_0 which would contain the output for the first experiment.
Additional replicates 1-10 would be named Homer_1, Homer_2, ... Homer_10. There are two important files which 
store the runtime parameters: Homer.desc contain a basic text output with all the parameters as they were read
by HapHazard itself. Similarly, there is another file called Rvars.R which is an R script that contains a 
small selection of parameter lists that can be loaded into R for an analysis pipeline.

In addition to these two files, this Homer_0 folder contains output for the clines and genotype cline data.

The file name contains information about its origin. 

'Homer.0.499.clines' is from experiment "Homer", replicate number "0", sample at generation "499" (the 500th
since the first generation is indexed as 0), and the extension indicates this is an allele frequency cline
file.

The clines file looks like this:

************************************************************************************************************
************************************************************************************************************
|chr,pos,D0_A0,D0_A1
|0,0,8,8
|0,0.01,8,8
|0,0.02,9,7
|0,0.03,7,9
|0,0.04,8,8
|0,0.05,7,9
|0,0.06,7,9
|0,0.07,8,8
|
*************************************************************************************************************

This is a comma-delimited text file that can be easily opened in a spreadsheet program or loaded into R as a
dataframe. These list the counts of ancestry at a genomic position as detected in the samples taken in the 
simulator. The headings are read as:

chr = chromosome (the index number 0, 1, 2, ... etc.)
pos = the position in Morgans on the chromosome.
D0_A0 = frequency of Ancestry 0 in Deme 0
D0_A1 = frequendy of Ancestry 1 in Deme 0

The .gclines files are the same, but instead list "genotype" clines, counts of the number of ancestry 1 at each
locus.

Inside Homer_0 are additional folders, BL_CHR0, BL_CHR1, and BL_CHR2. Each folder contains the block files (ending
with .bla) and marker files (ending with .mkr).

The block files are the heart of HapHazard's output, its raison d'etre.

Similar to the cline files, these are comma-delimited text and can be opened as spreadsheets or loaded into R
as dataframes. Each line defines an ancestry block and contains info about its "starting" junction. The junction
at the left or lowest genetic distance position of the block. The filename tells what is is and where it came from.

0.499.bla is a block file for chromosome 0, generation 499 (aka 500). Be careful. Other replicates/simulations will
name its block files the same way. Never remove them from their home directories unless you rename them to show where
they came from.

Here is an example:

************************************************************************************************************
************************************************************************************************************
|Deme,Individual,Haplotype,Chromosome,Type,Ancestry,Start,Start_Jun,Start_Born,End,Length
|0,0x9f43270,0x9b3eee8,0,2,1,0,0x99c75d0,0,0.00133017,0.00133017
|0,0x9f43270,0x9b3eee8,0,2,0,0.00133017,0x273f1728,475,0.00347399,0.00214383
|0,0x9f43270,0x9b3eee8,0,2,1,0.00347399,0x25cee910,484,0.00524139,0.0017674
|0,0x9f43270,0x9b3eee8,0,2,1,0.00524139,0x255f8740,387,0.0191183,0.0138769
|0,0x9f43270,0x9b3eee8,0,2,1,0.0191183,0x139e1790,98,0.0339613,0.0148431
|0,0x9f43270,0x9b3eee8,0,2,0,0.0339613,0xb81aea0,21,0.0402307,0.00626932
|0,0x9f43270,0x9b3eee8,0,2,1,0.0402307,0x1930a5b0,213,0.0416346,0.00140394
|0,0x9f43270,0x9b3eee8,0,2,0,0.0416346,0x1888f9e8,164,0.0483484,0.00671378
|0,0x9f43270,0x9b3eee8,0,2,1,0.0483484,0x291e6720,346,0.0546116,0.00626317
|
************************************************************************************************************

The headings are:
Deme = the deme from which this block was sampled.

Individual = a unique hexcode ID for the individual this block was found in. These addresses are unique to 
each individual in the simulation during the given generation.

Haplotype = another hexcode ID unique to each chromosome. The term haplotype was used just to avoid confusion
with the next heading.

Chromosome = the index of the chromosome, this reflects its position/order/type in the genome. 0 is always a
sex chromosome.

Type = the type of chromosome as an integer. See above section about chromosome types in input for type lables.

Ancestry = the integer that identifies the ancestry on the block that follows this junction.

Start = the start (lowest) genetic positon in Morgans.

Start_Jun = a hexcode ID for the junction itself, using this we can tell if other individuals share a junction
that is identical by descent IBD.

Start_Born = the generation in which the first junction of this kind was born. This actually tells you the generation
in which a recombination between two ancestries formed this junction.

End = the position in Morgans at which the next junction occurs.

Length = the length of the ancestry block in Morgans (End - Start).

Finally, there are .mkr files generated by the haphazard_makemarkers.pl script. These contain lists of ancestries
by position for each chromosome sampled. These are also comma-delimited text and can be used in spreadsheets or
R as data frames.

Here is an example:

************************************************************************************************************
************************************************************************************************************
Deme,Individual,Haplotype,Chromosome,Type,0.000000,0.010000,0.020000,0.030000,0.040000,0.050000,0.060000, ...
0,0xa41b1d0,0xa34eac0,0,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0, ...
0,0xa41b1d0,0xa085a40,0,2,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, ...
0,0xa265950,0xa1c2530,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ...
0,0xa265950,0xa677e00,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ...
0,0xa66f778,0xa0733a0,0,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ...
0,0xa66f778,0xa527ab0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ...
0,0xa33d7f0,0xa65acd8,0,2,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0, ...
0,0xa33d7f0,0xa619108,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1, ...
0,0xa439c80,0xa4a7278,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1, ...
0,0xa439c80,0xa5a7908,0,3,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, ...
0,0xa16ae68,0xa4453a0,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0, ...
0,0xa16ae68,0xa550e40,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0, ...
0,0xa61a288,0xa6f7420,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ...
0,0xa61a288,0xa22c310,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ...
0,0xa6d40f0,0xa2b5718,0,2,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, ...
0,0xa6d40f0,0xa5013e0,0,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, ...
0,0xa1a5868,0xa615570,0,2,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ...
0,0xa1a5868,0xa4d2a48,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, ...
0,0xa0f7038,0xa30bc08,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0, ...
0,0xa0f7038,0xa0e59b0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, ...
,,,,

************************************************************************************************************

The headings are:

Deme: The deme the chromosome came from.
Individual: The hexcode memory address of the individual, unique to each individual in a generation
Haplotype: The hexcode memory address of the chromosome, unique to each chromsome generation
Chromosome: The genomic index of the chromosome
Type: The type of chromosome
The remaining columns are the genetic positions along the chromsome for each marker. The ancestry is listed as the
integer associated with the ancestry.
